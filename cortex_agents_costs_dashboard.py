# Import python packages
import streamlit as st
import pandas as pd
import datetime
import json
import plotly.express as px
import plotly.graph_objects as go
from snowflake.snowpark.context import get_active_session

# Set page configuration
st.set_page_config(
    page_title="Snowflake Intelligence Cost Dashboard",
    page_icon="ðŸ¤–",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        background: linear-gradient(135deg, #29B5E8, #11567F);
        padding: 2rem 1rem 1rem 1rem;
        border-radius: 0.5rem;
        margin-bottom: 2rem;
        color: white;
        text-align: center;
    }
    
    .main-title {
        font-family: Arial, sans-serif;
        font-weight: bold;
        font-size: 2.5rem;
        color: white;
        margin: 0;
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
</style>
""", unsafe_allow_html=True)

# Header
header_html = """
<div class="main-header">
    <h1 class="main-title">ðŸ¤– SNOWFLAKE INTELLIGENCE COST DASHBOARD</h1>
    <div style="font-size: 1.1rem; opacity: 0.9;">
        Monitor and analyze costs for all Cortex Agents used in your Snowflake account
    </div>
</div>
"""
st.markdown(header_html, unsafe_allow_html=True)

# Get the current credentials
session = get_active_session()

@st.cache_data
def get_snowflake_edition():
    """Get Snowflake edition for cost estimation"""
    try:
        edition_query = """
        SELECT edition
        FROM SNOWFLAKE.ORGANIZATION_USAGE.ACCOUNTS
        WHERE account_name = CURRENT_ACCOUNT_NAME()
        """
        result = session.sql(edition_query).collect()
        if result:
            return result[0]['EDITION']
        return 'STANDARD'
    except Exception:
        return 'STANDARD'

def get_cost_per_credit(edition):
    """Get estimated cost per credit based on edition"""
    costs = {
        'STANDARD': 2.60,
        'ENTERPRISE': 3.90,
        'BUSINESS_CRITICAL': 5.20
    }
    return costs.get(edition.upper(), 2.60)

def format_cost(credits, cost_per_credit):
    """Format cost for display"""
    cost = credits * cost_per_credit
    if cost == 0:
        return "$0.00"
    elif cost < 0.01:
        return f"${cost:.4f}"
    else:
        return f"${cost:.2f}"

def format_credits(credits):
    """Format credits for display"""
    if credits == 0:
        return "0.000"
    elif credits < 0.001:
        return f"{credits:.6f}"
    elif credits < 1:
        return f"{credits:.3f}"
    else:
        return f"{credits:.2f}"

@st.cache_data
def get_warehouse_costs_breakdown(days):
    """Get warehouse costs breakdown for cortex vs non-cortex queries - performance optimized"""
    cost_query = f"""
    WITH cortex_warehouses AS (
      -- Step 1: Quickly identify warehouses with Cortex Analyst activity
      SELECT DISTINCT warehouse_name
      FROM snowflake.account_usage.query_history
      WHERE start_time >= DATEADD(DAY, -{days}, CURRENT_DATE)
        AND warehouse_name IS NOT NULL
        AND query_text LIKE '%Generated by Cortex Analyst%'
    ), filtered_queries AS (
      -- Step 2: Get only queries from relevant warehouses (much smaller dataset)
      SELECT
        query_id,
        warehouse_name,
        CASE WHEN query_text LIKE '%Generated by Cortex Analyst%' THEN 1 ELSE 0 END AS is_cortex_query
      FROM snowflake.account_usage.query_history
      WHERE start_time >= DATEADD(DAY, -{days}, CURRENT_DATE)
        AND warehouse_name IN (SELECT warehouse_name FROM cortex_warehouses)
    ), query_with_credits AS (
      -- Step 3: Join credits only for the filtered set (small join)
      SELECT
        fq.warehouse_name,
        fq.is_cortex_query,
        COALESCE(qa.credits_attributed_compute, 0) + COALESCE(qa.credits_used_query_acceleration, 0) AS total_credits
      FROM filtered_queries fq
      INNER JOIN snowflake.account_usage.query_attribution_history qa ON fq.query_id = qa.query_id
    )
    SELECT
      warehouse_name,
      CASE WHEN is_cortex_query = 1 THEN 'Cortex Analyst' ELSE 'Other Queries' END AS query_type,
      COUNT(*) AS query_count,
      SUM(total_credits) AS total_credits
    FROM query_with_credits
    GROUP BY warehouse_name, is_cortex_query
    ORDER BY warehouse_name, is_cortex_query DESC
    """
    
    try:
        result = session.sql(cost_query).to_pandas()
        return result
    except Exception as e:
        st.error(f"Could not fetch warehouse cost data: {str(e)}")
        return pd.DataFrame()

@st.cache_data  
def get_cortex_analyst_usage(days):
    """Get Cortex Analyst usage history"""
    usage_query = f"""
    SELECT
      START_TIME,
      END_TIME,
      REQUEST_COUNT,
      CREDITS,
      USERNAME
    FROM SNOWFLAKE.ACCOUNT_USAGE.CORTEX_ANALYST_USAGE_HISTORY
    WHERE START_TIME >= DATEADD(DAY, -{days}, CURRENT_DATE)
    ORDER BY START_TIME DESC
    """
    
    try:
        result = session.sql(usage_query).to_pandas()
        return result
    except Exception as e:
        st.error(f"Could not fetch Cortex Analyst usage data: {str(e)}")
        return pd.DataFrame()

@st.cache_data
def get_cortex_analyst_requests(days):
    """Get Cortex Analyst requests"""
    requests_query = f"""
    SELECT
      timestamp,
      semantic_model_name,
      user_name,
      latest_question,
      feedback
    FROM snowflake.local.CORTEX_ANALYST_REQUESTS_V
    WHERE timestamp >= DATEADD(DAY, -{days}, CURRENT_DATE)
    ORDER BY timestamp DESC
    LIMIT 1000
    """
    
    try:
        result = session.sql(requests_query).to_pandas()
        return result
    except Exception as e:
        st.error(f"Could not fetch Cortex Analyst requests data: {str(e)}")
        return pd.DataFrame()

# Initialize session state and configuration
if 'initialized' not in st.session_state:
    st.session_state.initialized = True

# Get Snowflake edition for cost estimation
edition = get_snowflake_edition()
cost_per_credit = get_cost_per_credit(edition)

# Sidebar configuration
st.sidebar.header("âš™ï¸ Configuration")

# Display/cost toggle
display_mode = st.sidebar.radio(
    "Display Mode:",
    ["Credits", "Estimated Cost"],
    help=f"Toggle between credits and estimated cost based on {edition} edition"
)

# Edition info
with st.sidebar.expander("ðŸ’¡ Cost Estimation Details", expanded=False):
    st.write(f"**Snowflake Edition:** {edition}")
    st.write(f"**Cost per Credit:** ${cost_per_credit:.2f}")
    st.write("**Note:** Costs are estimates based on typical pricing.")
    st.write("**Actual costs may vary based on your specific contract.**")

# Main content area
st.subheader("ðŸ’° Snowflake Intelligence Cost Analysis")

# Expandable info section
with st.expander("ðŸ“š Learn more about Snowflake Intelligence costs", expanded=False):
    st.markdown("""
    **Total costs for Snowflake Intelligence is derived from three main components in a pure consumption-based model:**
    
    1. **ðŸŽ¯ Token usage** - charged per million tokens for both input tokens (context and data the agent processes) and output tokens (the agent's responses, queries, and SQL statements)
    
    2. **ðŸ” Cortex Search costs** - consumption charges based on the size of knowledge base indexes when the agent accesses internal company data *(not included in this dashboard)*
    
    3. **ðŸ­ Warehouse compute costs** - standard Snowflake warehouse charges when the agent executes queries to answer questions
    
    ---
    
    **ðŸ“Š This dashboard covers components 1 & 3:**
    - **Cortex Analyst Usage**: Token consumption for text-to-SQL generation
    - **Warehouse Costs**: Compute costs for executing generated queries
    
    **âš ï¸ Note:** Cortex Search costs are not included in this dashboard and require separate monitoring.
    """)

# Create tabs for different time periods and data views
tab7, tab1, tab3, tab30, tab5, tab6 = st.tabs([
    "ðŸ“… 7 Days", "ðŸ“… 1 Day", "ðŸ“… 3 Days", "ðŸ“… 30 Days", 
    "ðŸ“Š Cortex Analyst Usage", "ðŸ“‹ Raw Requests Data"
])

# Function to render period tab content
def render_period_tab(days, period_name, display_mode, cost_per_credit):
    st.markdown(f"### ðŸ“Š Costs for Last {period_name}")
    
    # Get data
    warehouse_data = get_warehouse_costs_breakdown(days)
    cortex_usage_data = get_cortex_analyst_usage(days)
    
    # Calculate totals
    warehouse_cortex_credits = 0
    warehouse_other_credits = 0
    cortex_analyst_credits = cortex_usage_data['CREDITS'].sum() if not cortex_usage_data.empty else 0
    
    if not warehouse_data.empty:
        cortex_mask = warehouse_data['QUERY_TYPE'] == 'Cortex Analyst'
        other_mask = warehouse_data['QUERY_TYPE'] == 'Other Queries'
        warehouse_cortex_credits = warehouse_data[cortex_mask]['TOTAL_CREDITS'].sum()
        warehouse_other_credits = warehouse_data[other_mask]['TOTAL_CREDITS'].sum()
    
    total_cortex_credits = warehouse_cortex_credits + cortex_analyst_credits
    
    # Display metrics
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        value = total_cortex_credits
        display_value = format_credits(value) if display_mode == "Credits" else format_cost(value, cost_per_credit)
        st.metric(
            f"ðŸ’° Total Snowflake Intelligence {'Credits' if display_mode == 'Credits' else 'Cost'}",
            display_value,
            help="Total credits/cost for SQL queries + Cortex Analyst usage"
        )
    
    with col2:
        value = cortex_analyst_credits
        display_value = format_credits(value) if display_mode == "Credits" else format_cost(value, cost_per_credit)
        st.metric(
            f"ðŸ¤– Cortex Analyst {'Credits' if display_mode == 'Credits' else 'Cost'}",
            display_value,
            help="Credits/cost for text-to-SQL generation"
        )
    
    with col3:
        value = warehouse_cortex_credits
        display_value = format_credits(value) if display_mode == "Credits" else format_cost(value, cost_per_credit)
        st.metric(
            f"ðŸ­ Warehouse {'Credits' if display_mode == 'Credits' else 'Cost'}",
            display_value,
            help="Credits/cost for the SQL query execution"
        )
    
    with col4:
        cortex_queries = warehouse_data[warehouse_data['QUERY_TYPE'] == 'Cortex Analyst']['QUERY_COUNT'].sum() if not warehouse_data.empty else 0
        st.metric(
            "ðŸ” Cortex Analyst Queries",
            f"{cortex_queries:,}",
            help="Number of queries executed by Cortex Analyst"
        )
    
    # Warehouse breakdown chart and table - only show warehouses with Cortex Analyst activity
    if not warehouse_data.empty:
        # Prepare data for stacked bar chart and filter for warehouses with Cortex Analyst activity
        pivot_data = warehouse_data.pivot(index='WAREHOUSE_NAME', columns='QUERY_TYPE', values='TOTAL_CREDITS').fillna(0)
        
        # Only keep warehouses that have Cortex Analyst credits > 0
        if 'Cortex Analyst' in pivot_data.columns:
            cortex_warehouses = pivot_data[pivot_data['Cortex Analyst'] > 0]
            
            if not cortex_warehouses.empty:
                st.markdown("#### ðŸ“ˆ Warehouse Credits Breakdown")
                
                fig = go.Figure()
                
                # Prepare y-values based on display mode
                cortex_y_values = cortex_warehouses['Cortex Analyst']
                other_y_values = cortex_warehouses['Other Queries'] if 'Other Queries' in cortex_warehouses.columns else pd.Series([0]*len(cortex_warehouses))
                
                if display_mode == "Estimated Cost":
                    cortex_y_values = cortex_y_values * cost_per_credit
                    other_y_values = other_y_values * cost_per_credit
                
                fig.add_trace(go.Bar(
                    name='Cortex Analyst',
                    x=cortex_warehouses.index,
                    y=cortex_y_values,
                    marker_color='#29B5E8'
                ))
                
                if 'Other Queries' in cortex_warehouses.columns:
                    fig.add_trace(go.Bar(
                        name='Other Queries',
                        x=cortex_warehouses.index,
                        y=other_y_values,
                        marker_color='#11567F'
                    ))
                
                fig.update_layout(
                    title=f"Warehouse Usage Breakdown - Last {period_name}",
                    xaxis_title="Warehouse",
                    yaxis_title="Credits Used" if display_mode == "Credits" else "Estimated Cost ($)",
                    barmode='stack',
                    font_family="Arial"
                )
                
                st.plotly_chart(fig, use_container_width=True)
                
                # Detailed breakdown table - one row per warehouse
                st.markdown("#### ðŸ“‹ Detailed Warehouse Breakdown")
                
                # Create table with one row per warehouse and separate columns
                table_data = []
                for warehouse in cortex_warehouses.index:
                    cortex_credits = cortex_warehouses.loc[warehouse, 'Cortex Analyst']
                    other_credits = cortex_warehouses.loc[warehouse, 'Other Queries'] if 'Other Queries' in cortex_warehouses.columns else 0
                    
                    # Get query counts
                    cortex_queries_count = warehouse_data[
                        (warehouse_data['WAREHOUSE_NAME'] == warehouse) & 
                        (warehouse_data['QUERY_TYPE'] == 'Cortex Analyst')
                    ]['QUERY_COUNT'].iloc[0] if len(warehouse_data[
                        (warehouse_data['WAREHOUSE_NAME'] == warehouse) & 
                        (warehouse_data['QUERY_TYPE'] == 'Cortex Analyst')
                    ]) > 0 else 0
                    
                    other_queries_count = warehouse_data[
                        (warehouse_data['WAREHOUSE_NAME'] == warehouse) & 
                        (warehouse_data['QUERY_TYPE'] == 'Other Queries')
                    ]['QUERY_COUNT'].iloc[0] if len(warehouse_data[
                        (warehouse_data['WAREHOUSE_NAME'] == warehouse) & 
                        (warehouse_data['QUERY_TYPE'] == 'Other Queries')
                    ]) > 0 else 0
                    
                    if display_mode == "Credits":
                        table_data.append({
                            'WAREHOUSE_NAME': warehouse,
                            'CORTEX_ANALYST_CREDITS': format_credits(cortex_credits),
                            'OTHER_CREDITS': format_credits(other_credits),
                            'CORTEX_ANALYST_QUERIES': cortex_queries_count,
                            'OTHER_QUERIES': other_queries_count
                        })
                    else:
                        table_data.append({
                            'WAREHOUSE_NAME': warehouse,
                            'CORTEX_ANALYST_COST': format_cost(cortex_credits, cost_per_credit),
                            'OTHER_COST': format_cost(other_credits, cost_per_credit),
                            'CORTEX_ANALYST_QUERIES': cortex_queries_count,
                            'OTHER_QUERIES': other_queries_count
                        })
                
                table_df = pd.DataFrame(table_data)
                st.dataframe(table_df, use_container_width=True, hide_index=True)
                
            else:
                st.info(f"ðŸ’¡ No Cortex Analyst activity found for the last {period_name}.")
        else:
            st.info(f"ðŸ’¡ No Cortex Analyst activity found for the last {period_name}.")
    else:
        st.info(f"ðŸ’¡ No warehouse activity found for the last {period_name}.")
    
    # Cortex Analyst usage summary
    if not cortex_usage_data.empty:
        st.markdown("#### ðŸ¤– Cortex Analyst Usage Summary")
        col1, col2 = st.columns(2)
        
        with col1:
            total_requests = cortex_usage_data['REQUEST_COUNT'].sum()
            st.metric("Total Requests", f"{total_requests:,}")
        
        with col2:
            unique_users = cortex_usage_data['USERNAME'].nunique()
            st.metric("Unique Users", str(unique_users))

# Render period tabs
with tab7:
    render_period_tab(7, "7 Days", display_mode, cost_per_credit)

with tab1:
    render_period_tab(1, "1 Day", display_mode, cost_per_credit)

with tab3:
    render_period_tab(3, "3 Days", display_mode, cost_per_credit)

with tab30:
    render_period_tab(30, "30 Days", display_mode, cost_per_credit)

# Cortex Analyst Usage Tab
with tab5:
    st.markdown("### ðŸ¤– Cortex Analyst Usage Details")
    
    period_days = st.selectbox("Select Time Period:", [7, 1, 3, 30], index=0, key="usage_period")
    usage_data = get_cortex_analyst_usage(period_days)
    
    if not usage_data.empty:
        # Summary metrics
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            total_credits = usage_data['CREDITS'].sum()
            display_value = format_credits(total_credits) if display_mode == "Credits" else format_cost(total_credits, cost_per_credit)
            st.metric(f"Total {'Credits' if display_mode == 'Credits' else 'Cost'}", display_value)
        
        with col2:
            total_requests = usage_data['REQUEST_COUNT'].sum()
            st.metric("Total Requests", f"{total_requests:,}")
        
        with col3:
            unique_users = usage_data['USERNAME'].nunique()
            st.metric("Unique Users", str(unique_users))
        
        with col4:
            avg_credits_per_request = total_credits / total_requests if total_requests > 0 else 0
            display_value = format_credits(avg_credits_per_request) if display_mode == "Credits" else format_cost(avg_credits_per_request, cost_per_credit)
            st.metric(f"Avg {'Credits' if display_mode == 'Credits' else 'Cost'}/Request", display_value)
        
        # Usage over time chart
        st.markdown("#### ðŸ“ˆ Usage Over Time")
        if len(usage_data) > 1:
            # Prepare chart data based on display mode
            chart_data = usage_data.copy()
            if display_mode == "Estimated Cost":
                chart_data['DISPLAY_VALUES'] = chart_data['CREDITS'] * cost_per_credit
                y_column = 'DISPLAY_VALUES'
                title = "Cortex Analyst Cost Over Time"
            else:
                chart_data['DISPLAY_VALUES'] = chart_data['CREDITS']
                y_column = 'DISPLAY_VALUES'
                title = "Cortex Analyst Credits Over Time"
            
            fig = px.line(
                chart_data,
                x='START_TIME',
                y=y_column,
                title=title,
                color_discrete_sequence=['#29B5E8']
            )
            fig.update_layout(
                xaxis_title="Time",
                yaxis_title="Credits Used" if display_mode == "Credits" else "Estimated Cost ($)",
                font_family="Arial"
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # Detailed usage table
        st.markdown("#### ðŸ“‹ Detailed Usage History")
        display_usage = usage_data.copy()
        if display_mode == "Estimated Cost":
            display_usage['ESTIMATED_COST'] = display_usage['CREDITS'].apply(lambda x: format_cost(x, cost_per_credit))
        else:
            display_usage['CREDITS'] = display_usage['CREDITS'].apply(format_credits)
        
        st.dataframe(display_usage, use_container_width=True, hide_index=True)
    else:
        st.info(f"ðŸ’¡ No Cortex Analyst usage found for the last {period_days} days.")

# Raw Requests Data Tab  
with tab6:
    st.markdown("### ðŸ“‹ Cortex Analyst Requests Raw Data")
    
    period_days = st.selectbox("Select Time Period:", [7, 1, 3, 30], index=0, key="requests_period")
    requests_data = get_cortex_analyst_requests(period_days)
    
    if not requests_data.empty:
        st.write(f"**Total Requests:** {len(requests_data):,}")
        st.write(f"**Date Range:** Last {period_days} days")
        
        # Summary by semantic model
        st.markdown("#### ðŸ“Š Requests by Semantic Model")
        semantic_col = None
        for col in ['semantic_model_name', 'SEMANTIC_MODEL_NAME']:
            if col in requests_data.columns:
                semantic_col = col
                break
        
        if semantic_col and not requests_data[semantic_col].isna().all():
            model_summary = requests_data[requests_data[semantic_col].notna()].groupby([semantic_col]).size().reset_index(name='REQUEST_COUNT')
            model_summary = model_summary.sort_values('REQUEST_COUNT', ascending=False)
            st.dataframe(model_summary, use_container_width=True, hide_index=True)
        else:
            st.info("No semantic model data available.")
        
        # Summary by user
        st.markdown("#### ðŸ‘¤ Requests by User")
        user_col = None
        for col in ['user_name', 'USER_NAME']:
            if col in requests_data.columns:
                user_col = col
                break
                
        if user_col and not requests_data[user_col].isna().all():
            user_summary = requests_data[requests_data[user_col].notna()].groupby([user_col]).size().reset_index(name='REQUEST_COUNT')
            user_summary = user_summary.sort_values('REQUEST_COUNT', ascending=False)
            st.dataframe(user_summary, use_container_width=True, hide_index=True)
        else:
            st.info("No user data available.")
        
        # Raw requests table
        st.markdown("#### ðŸ“‹ Raw Requests Data")
        st.dataframe(requests_data, use_container_width=True, hide_index=True)
    else:
        st.info(f"ðŸ’¡ No Cortex Analyst requests found for the last {period_days} days.")

# Footer
st.markdown("---")
st.markdown(f"""
<div style="text-align: center; color: #666; font-size: 0.9rem;">
    <p>ðŸ’¡ <strong>Tip:</strong> Costs include warehouse execution (queries with 'Generated by Cortex Analyst') and Cortex Analyst text-to-SQL generation.</p>
    <p>ðŸ“Š Cost estimates based on {edition} edition (${cost_per_credit:.2f}/credit). Actual costs may vary.</p>
    <p>ðŸ•’ Data is sourced from ACCOUNT_USAGE views with up to 3-hour latency.</p>
</div>
""", unsafe_allow_html=True)